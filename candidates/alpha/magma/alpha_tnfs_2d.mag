/* Magma code with "intrinsic" so that there is some documentation for the end user

   Implementation of algorithms in the paper:
   On the alpha value of polynomials in the Tower Number Field Sieve Algorithm,
   Aurore Guillevic (Inria Nancy, France) and Shashank Singh (IISER Bhopal, India)
   eprint 2019/885.
   
   Implementation: Aurore Guillevic and Shashank Singh

   See also Bai-Gaudry-Hanrot-Thom'e-Zimmermann 's implementation for NFS 2D:
   SageMath: cado-nfs/polyselect/alpha_2d.sage
   C: cado-nfs/polyselect/auxiliary.c
   (In the following, there is a recursive version and an iterative version 
   with a list)

   Note that the files cado-nfs/sieve/makefb.{sage,c} contain an efficient and 
   exact implementation of a lifting process to compute the roots of f mod l^k

   main exported function:
     alpha_TNFS_2d(f,B)
   which returns a float number.

   Use 
   Attach("alpha_tnfs_2d.mag");

   To read the documentation of an "intrinsic" function or procedure, type
   number_of_roots_TNFS;
   lift_Fl_ZZ;
   average_valuation_affine_TNFS_I_principal;

*/
// this is a package, but it is not supposed to change. To increase efficiency,
// use the directive "freeze"
freeze;
 
SetClassGroupBounds("GRH");
ZZ := Integers();
QQ := Rationals();

intrinsic number_of_roots_TNFS(f :: RngUPolElt, FqZ :: RngUPol, map_Kh_Fq :: Map) -> RngIntElt, BoolElt
{   Computes the number of roots of f, a polynomial in Kh[x], mod q where q is a prime power.
    First, map f to Fq[z], then computes the number of distinct roots.
}
    local fq, s, proj_I;
    proj_I := false;
    fq := FqZ ! [map_Kh_Fq(coeff_i) : coeff_i in Eltseq(f)];
    if fq ne 0 then
	s := # Roots(fq);
	if Degree(fq) lt Degree(f) then
	    s +:= 1;
	    proj_I := true;// the ideal divides the leading coeff
	end if;
    else
	// f reducing to zero mod I is a degenerate case. Not clear what
	// we should return...
	// note: this should never happen, otherwise it means that the content of f is not 1
        print "Warning, counting roots of zero polynomial\n";
        s := Degree(f);
    end if;
    return s, proj_I;
end intrinsic;

intrinsic lift_Fl_ZZ(a :: FldFinElt) -> RngIntElt
{   lift from ZZ/lZZ to ZZ, minimize the absolute value
    (centered representative in [-(l-1)/2, (l-1)/2]).
}
    local l, lift;
    l := Characteristic(Parent(a));
    lift := ZZ ! a;
    if Abs(lift) le Abs(lift - l) then
	return lift;
    else
	return lift-l;
    end if;
end intrinsic;

intrinsic is_bad_ideal(I :: RngOrdIdl, I_disc_f :: RngOrdIdl, Oh1 :: RngOrdIdl) -> BoolElt
{   I is an ideal of Oh,
    Oh1 is the ideal generated by 1 in Oh,
    I_disc_f is the ideal generated by the discriminant of f
    Returns true if I is coprime to I_disc_f (I is a good ideal), and false otherwise (I is a bad ideal)
}
    return not ((I_disc_f + I) eq Oh1);
end intrinsic;

procedure average_valuation_affine_TNFS_I_principal_rec(I, Norm_I, gamma, FqZ, map_Kh_Fq, ~L, ~v)
/*{   Remove and process the first element (head) of the list L.
    I is a principal prime ideal of Oh
    Norm_I is the norm of I (a positive integer)
    gamma is a generator of I
    L is a list of sub-polys of f (the f(r_i + x*gamma)) to be processed
    v is a valuation (only used to return a value)
    Fq is the residue class field of I
    FqZ is a univariate polynomial ring of Fq (FqZ = Fq[Z])
    map_Kh_Fq is a map from the number field Kh to the residue class field Fq (reduces the coefficients mod q)
    Kh is a number field
    Oh is the maximal order of Kh

    this procedure pops the first element of L, process it:
    - compute vi = the valuation at I of the content of f
    - compute f1 = f / gamma^vi, map f1 from Kh[x] to Fq[z]
    - compute the roots r_i of f1 in Fq
       + if the roots are multiple, lift the roots in Oh, and
         add at the end of L the new polynomials f2 = f(r_i+gamma*x)
       + otherwise the lifting process is over for that r_i, add the corresponding valuation.
}*/
    local f, j, fv, val_i, dfv, fv_FqZ, dfv_FqZ, r, lift_r, f2, Oh, Kh;
    Oh := Order(I);
    Kh := NumberField(Oh);
    f := L[1][1];
    j := L[1][2];
    Remove(~L,1);
    // the Content function in Magma does not compute a Gcd in ZZ
    //val_i := Valuation(Content(f), I); // -> does not do what I want
    val_i := Min([Valuation(ideal<Oh|fi>, I): fi in Coefficients(f)]);
    if val_i gt 0 then
	fv := f div gamma^val_i;
    else
	fv := f;
    end if;
    val_i := QQ!val_i;
    dfv := Derivative(fv);
    // now map coefficients of f and df to Oh/(I) = F_{p^e}
    // to get f and df in F_{p^e} [x]
    fv_FqZ := FqZ ! [map_Kh_Fq(coeff_i) : coeff_i in Eltseq(fv)];
    dfv_FqZ := FqZ ! [map_Kh_Fq(coeff_i) : coeff_i in Eltseq(dfv)];
    // note: usually, Magma requires a monic polynomial to define a finite field
    for r in Roots(fv_FqZ) do // easy to compute roots in a finite field
	if (Evaluate(dfv_FqZ, r[1]) ne 0) then
	    //<=> if not (Evaluate(dfv, lift_r) in I) <=> fv'(r) != 0
            // r is a simple root, with multiplicity one.
            val_i +:= 1/(Norm_I-1);
        else// r is a multiple root, meaning a root of f and f',
	    // continue the lifting process until f'(r) !=0
	    lift_r := Kh ! ([lift_Fl_ZZ(coeff_i): coeff_i in Eltseq(r[1])] cat [0: i in [1 .. (Degree(Kh) - Degree(I))]]);
	    f2 := Evaluate(fv, lift_r + (Kh ! gamma)*Parent(fv).1);
	    Append(~L, <f2,j+1>);
	end if;
    end for;
    v := val_i/(Norm_I^j); // returned value "by pointer"
end procedure;

intrinsic average_valuation_affine_TNFS_I_principal(f :: RngUPolElt, I :: RngOrdIdl, Norm_I :: RngIntElt, gamma :: RngOrdElt, FqZ :: RngUPol, map_Kh_Fq :: Map) -> FldRatElt
{   f is a polynomial in Oh[x], of Kh[x]
    I is a principal prime ideal of Oh
    Norm_I is the norm of I (a positive integer)
    gamma is a generator of I
    Fq is the residue class field of I
    FqZ is a univariate polynomial ring of Fq (FqZ = Fq[Z])
    map_Kh_Fq is a map from the number field Kh to the residue class field Fq (reduces the coefficients mod q)
    Kh is a number field
    Oh is the maximal order of Kh

    This function starts the recursive lifting process for the multiple roots of f mod I.
    Returns the average valuation at I.
    The recursive function calls are replaced by an iterative call with a list L (a "manual" stack).
}
    local L, v, vk;
    L := [<f,0>]; // list of <f,j> where j is the recursive call depth
    v := QQ!0;
    while #L gt 0 do
	vk := QQ!0;
	average_valuation_affine_TNFS_I_principal_rec(I, Norm_I, gamma, FqZ, map_Kh_Fq, ~L, ~vk);
	v := v+vk;
    end while;
    return v;
end intrinsic;

intrinsic map_Kh_Fq_bivariate_pol_ring(Kh_x1x2 :: RngMPol, Fq_z1z2 :: RngMPol, fv :: RngMPolElt, map_Kh_Fq :: Map) -> RngMPolElt
{   Map a bivariate polynomial fv(x1,x2) in Kh[x1,x2] to Fq[z1,z2],
    that is, reduce each coefficient of fv in Kh to Fq.
    Magma does not do it directly with bivariate polynomials.
   
    Coefficients(f) returns the coefficients as "base" coefficients, exactly in the same order as Monomials(f).
}
    local coeffs_Fq, monomials;
    coeffs_Fq := [map_Kh_Fq(coeff_i) : coeff_i in Coefficients(fv)];
    monomials_Fq := [Fq_z1z2.1^Degree(m,1)*Fq_z1z2.2^Degree(m,2): m in Monomials(fv)];
    return &+ [coeffs_Fq[i]*monomials_Fq[i] : i in [1..#monomials_Fq]];
end intrinsic;

intrinsic Roots_bivariate(fv_z1z2 :: RngMPolElt, Fq_Z :: RngUPol, delta :: RngOrdElt, gamma :: RngOrdElt, Oh1 :: RngOrdIdl) -> SeqEnum, SeqEnum
{   Second version of root computation of a bivariate polynomial modulo an ideal.
    Hints from Pierre-Jean Spaenlehauer, Inria Nancy
    Toy example:
    q := 13;
    K := GF(q);
    R<x,y> := PolynomialRing(K, 2);
    f := x^10*y^2-3*x^3*y^4 + 2;
    roots := Variety(Ideal([f, x^q-x, y^q-y]));
    Evaluate(f, roots[1]); // gives 0
    For larger values, this is not efficient.
}
    local Fq, roots, roots_Fq, roots_IJ, roots_I, Oh, q, Ri, Rj, rI,diff_deg, X_, Y_;
    Oh := Order(Oh1);
    Fq := CoefficientRing(Fq_Z);
    X_ := Parent(fv_z1z2).1;
    Y_ := Parent(fv_z1z2).2;
    roots_I := [];
    roots_IJ := [];
    roots_Fq := [];
    diff_deg := Degree(Oh) - Degree(Fq);
    q := #Fq;
    roots := Variety(Ideal([fv_z1z2, X_^q-X_, Y_^q-Y_]));
    printf "computing roots with Variety(). Found %o roots. ", #roots;
    // now see if there are "duplicates"
    for r in roots do
	if r ne <0,0> then
	    if Degree(Fq) eq 1 then
		Ri := lift_Fl_ZZ(r[1]);
		Rj := lift_Fl_ZZ(r[2]);
		rI := ideal<Oh | Ri*delta + Rj*gamma >; //assume that Fq is prime
	    else
		Ri := Oh!([lift_Fl_ZZ(i1e): i1e in Eltseq(r[1])] cat [0: k in [1..diff_deg]]);
		Rj := Oh!([lift_Fl_ZZ(i2e): i2e in Eltseq(r[2])] cat [0: k in [1..diff_deg]]);
		rI := ideal<Oh | Ri*delta + Rj*gamma >;
	    end if;
	    // test wether the roots are "duplicates",
	    // that is ideal<Oh| i1*delta + j1*gamma> = ideal<Oh| i2*delta + j2*gamma>
	    j := 1;
	    while (j le #roots_I) and ((roots_Fq[j] eq [0,0]) or (rI + roots_I[j]) eq Oh1) do// jump over [0,0]
		j +:= 1;
	    end while;
	    if j gt #roots_I then
		Append(~roots_I, rI);
		Append(~roots_IJ, [Ri,Rj]);
		Append(~roots_Fq, [r[1],r[2]]);
	    end if;
	end if;
    end for;
    if (#roots_I lt (#Fq-1)) and (Evaluate(fv_z1z2, [0,0]) eq 0) then // otherwise, adding [0,0] as another root will make a full set of roots: we are supposed to have #roots = #Fq <=> val_I(f) > 0 but this is not the case
	Append(~roots_I, ideal<Oh | 0>);
	Append(~roots_IJ, [0,0]);
	Append(~roots_Fq, [Fq!0,Fq!0]);
    end if;
    printf "%o were duplicate roots.\n", #roots - #roots_Fq;
    return roots_Fq, roots_IJ;
end intrinsic;

intrinsic Roots_bivariate_enum(fv_z1z2 :: RngMPolElt, Fq_Z :: RngUPol, delta :: RngOrdElt, gamma :: RngOrdElt, Oh1 :: RngOrdIdl) -> SeqEnum, SeqEnum
{   Compute the roots of a bivariate polynomial fv_z1z2 in Fq[z1,z2] where Fq is a finite field
    by enumeration: enumerate all the pairs (s1,s2) in Fq x Fq
    Lift each pair to (c1,c2) in ZZ[x] x ZZ[x]
    c1,c2 are polynomials of integer coefficients (centered representatives) and degree at most Degree(Fq) - 1.
    Map (c1,c2) to Kh x Kh (change x to Kh.1)
    Map each (c1,c2) to an ideal in Oh generated by c1*delta + c2*gamma
 
    remove the pairs (ci,cj) that map to an ideal already encoutered with another pair (c1,c2)

    Returns a list of roots (pairs (s1,s2) in Fq x Fq) and the list of corresponding roots in Oh

    Technical issue: what to do with the root (0,0)?
    Apparently (0,0) can be a valid root.
    if there is a projective root, then this function is called with Evaluate(Reverse(f), delta*x1+gamma*x2)
}
    local Fq, roots_Fq, roots_I, roots_IJ, nb_roots, diff_deg, i1, i2, j, fi1, Oh, rI, Ri, Rj;
    Fq := CoefficientRing(Fq_Z);
    Oh := Order(Oh1);
    roots_I := [];
    roots_IJ := [];
    roots_Fq := [];
    diff_deg := Degree(Oh) - Degree(Fq);
    nb_roots := 0;
    for i2 in Fq do
	fi2 := Evaluate(fv_z1z2, [Fq_Z.1,i2]); // so that fi1 is univariate
	if Degree(fi2) ge 1 then
	    list_i1 := Roots(fi2);
	else
	    list_i1 := [];
	end if;
	nb_roots +:= #list_i1;
	for i1 in list_i1 do
	    if (i2 ne 0) or (i1[1] ne 0) then // how do I do with [0,0] ???
		if Degree(Fq) eq 1 then
		    Ri := lift_Fl_ZZ(i1[1]);
		    Rj := lift_Fl_ZZ(i2);
		    rI := ideal<Oh | Ri*delta + Rj*gamma >; //assume that Fq is prime
		else
		    Ri := Oh!([lift_Fl_ZZ(i1e): i1e in Eltseq(i1[1])] cat [0: k in [1..diff_deg]]);
		    Rj := Oh!([lift_Fl_ZZ(i2e): i2e in Eltseq(i2)] cat [0: k in [1..diff_deg]]);
		    rI := ideal<Oh | Ri*delta + Rj*gamma >;
		end if;
		// test wether the roots are "duplicates",
		// that is ideal<Oh| i1*delta + j1*gamma> = ideal<Oh| i2*delta + j2*gamma>
		j := 1;
		while (j le #roots_I) and ((roots_Fq[j] eq [0,0]) or (rI + roots_I[j]) eq Oh1) do// jump over [0,0]
		    j +:= 1;
		end while;
		if j gt #roots_I then
		    Append(~roots_I, rI);
		    Append(~roots_IJ, [Ri,Rj]);
		    Append(~roots_Fq, [i1[1],i2]);
		end if;
	    end if;
	end for;
    end for;
    // now [0,0]
    if (#roots_I lt (#Fq-1)) and (Evaluate(fv_z1z2, [0,0]) eq 0) then // otherwise, adding [0,0] as another root will make a full set of roots: we are supposed to have #roots = #Fq <=> val_I(f) > 0 but this is not the case
	Append(~roots_I, ideal<Oh | 0>);
	Append(~roots_IJ, [0,0]);
	Append(~roots_Fq, [Fq!0,Fq!0]);
    end if;
    printf "computing roots by enumeration. Found %o roots, %o were duplicate roots.\n", nb_roots, nb_roots-#roots_Fq;

    return roots_Fq, roots_IJ;
end intrinsic;

procedure average_valuation_affine_TNFS_I_not_principal_rec(I, Norm_I, delta, gamma, Oh1, FqZ, Fq_z1z2, map_Kh_Fq, Kh_x1x2, ~L, ~v: Reverse_f:=false)
/*{
    I is a non-principal prime ideal of Oh, and there is no generator gamma of I, but two generators (delta, gamma)
    L is a list of sub-polys of f (the f(r_i + x1*gamma+x2*delta)) to be processed
    the polynomials f are bivariate in x1,x2
    v is a valuation (only used to return a value)
    this procedure gets the first element of L, process it (as in the univariate case), and
    add at the end of L the new polynomials f2 = f(r_i+gamma*x1+delta*x2) to be processed.
 }*/
    local f, j, val_i, lcm, fv, dfv, fv_FqZ, dfv_FqZ, dfv1, dfv2, dfv1_FqZ, dfv2_FqZ, r, lift_r, f2, Oh, Kh;
    Oh := Order(Oh1);
    Kh := NumberField(Oh);
    f := L[1][1];
    j := L[1][2];
    Remove(~L,1);
    // the Content function in Magma does not compute a Gcd in ZZ
    // use Coefficients() instead of Eltseq for compatibiliy with multivariate (especially bivariate) polynomials
    //val_i := Valuation(Content(f), I);// Content not properly defined for bivariate polys
    //val_i := Min([Valuation(ideal<Oh|fi>, I): fi in Coefficients(f)]);
    val_i := Min([Valuation(fi, I): fi in Coefficients(f)]); // does work also without a cast in Oh
    if val_i gt 0 then
	// since gamma has not ezxactly norm q but a multiple of q (because gamma is not a generator of I),
	// then divides by gamma^val_i but re-multiples by something to obtain a polynomial with integer coefficients
	fv := f / gamma^val_i;
	// now just re-multiply to get integer coefficients in ZZ instead of in QQ
	// re-multiply by Norm(ideal<Oh|gamma>)/Norm_I?
	lcm := Lcm([ZZ!Denominator(fv_ij): fv_ij in &cat[Eltseq(fv_i): fv_i in Coefficients(fv)]]);
	// what does this ? fv can have rational coefficents when ZZ[ah] is a subring of Oh (coefficients 1/2 are allowed for example)
	// multiply fv above by an integer to cancel the denominators, but avoid to cancel too much: cancel only the denominators due to dividing by gamma^val_i
	fv *:= Gcd(ZZ!lcm,(ZZ!(Abs(ZZ!Norm(ideal<Oh|gamma>))/Norm_I))^val_i);
    else
	fv := f;
    end if;
    val_i := QQ!val_i;
    if Rank(Parent(f)) eq 1 then // f is actually univariate the 1st time
	dfv := Derivative(fv);
	// now map coefficients of f and df to Oh/(I) = F_{p^e}
	// to get f and df in F_{p^e} [x]
	fv_FqZ := FqZ ! [map_Kh_Fq(coeff_i) : coeff_i in Coefficients(fv)];
	dfv_FqZ := FqZ ! [map_Kh_Fq(coeff_i) : coeff_i in Coefficients(dfv)];
	for r in Roots(fv_FqZ) do // easy to compute roots in a finite field
	    //if not (Evaluate(dfv, lift_r) in I) then // fv'(r) != 0
	    if (Evaluate(dfv_FqZ, r[1]) ne 0) then // fv'(r) != 0
		// r is a simple root, with multiplicity one.
		val_i +:= 1/(Norm_I-1);
	    else// r is a multiple root, meaning a root of f and f',
		// continue the lifting process until f'(r) !=0
		// fill with zeros the list because Magma requires a list of exactly the good length to map
		lift_r := Kh ! ([lift_Fl_ZZ(coeff_i): coeff_i in Eltseq(r[1])] cat [0: i in [1 .. (Degree(Kh) - Degree(I))]]);
		f2 := Evaluate(fv, lift_r + (Kh ! delta)*Kh_x1x2.1 + (Kh ! gamma)*Kh_x1x2.2);
		if #L eq 0 then
		    L := [<f2,j+1>]; // Append does not always work properly for an empty list
		else
		    Append(~L, <f2,j+1>);
		end if;
	    end if;
	end for;
	v := val_i/(Norm_I^j); // returned value "by pointer"
    else
	fv_Fq_z1z2 := map_Kh_Fq_bivariate_pol_ring(Kh_x1x2, Fq_z1z2, fv, map_Kh_Fq);
	// f is bivariate, the Roots function is not defined.
	if Degree(fv_Fq_z1z2,1) eq 0 and Degree(fv_Fq_z1z2,2) eq 0 then // no root
	    v := val_i/(Norm_I^j);
	else
	    //if Degree(fv_Fq_z1z2,1) lt Characteristic(Fq) then # Magma can do it
		// list_r, list_r_Oh := Roots_bivariate(fv_Fq_z1z2, FqZ, delta, gamma, Oh1);
		list_r, list_r_Oh := Roots_bivariate_enum(fv_Fq_z1z2, FqZ, delta, gamma, Oh1);
		// this function also detect and remove duplicate roots (whose lift in Oh define the same ideal in Oh)
	    //else
		//printf "roots_bivariate: no comparison to Magma code possible.\n";
		//list_r, list_r_Oh := Roots_bivariate_enum(fv_Fq_z1z2, FqZ, delta, gamma, Oh1);
	    //end if;
	    // fv will be multivariate and derivative is with respect to a given variable x1 or x2
	    dfv1 := Derivative(fv,Parent(fv).1);
	    dfv2 := Derivative(fv,Parent(fv).2);
	    dfv1_Fq_z1z2 := map_Kh_Fq_bivariate_pol_ring(Kh_x1x2, Fq_z1z2, dfv1, map_Kh_Fq);
	    dfv2_Fq_z1z2 := map_Kh_Fq_bivariate_pol_ring(Kh_x1x2, Fq_z1z2, dfv2, map_Kh_Fq);

	    for i_r:= 1 to #list_r do // r is [r1,r2]
		r := list_r[i_r];
		r1 := r[1]; r2 := r[2];
		//lift_r1 := Kh ! ([lift_Fl_ZZ(coeff_i): coeff_i in Eltseq(r1)] cat [0: i in [1 .. (Degree(Kh) - Degree(I))]]);
		//lift_r2 := Kh ! ([lift_Fl_ZZ(coeff_i): coeff_i in Eltseq(r2)] cat [0: i in [1 .. (Degree(Kh) - Degree(I))]]);
		//lift_r := [lift_r1,lift_r2];
		lift_r := list_r_Oh[i_r];
		//if (not Evaluate(dfv1, lift_r) in I) or (not Evaluate(dfv2,lift_r) in I) then
		if (Evaluate(dfv1_Fq_z1z2, r) ne 0) or (Evaluate(dfv2_Fq_z1z2, r) ne 0) then
		    val_i +:= 1/(Norm_I-1);
		else
		    f2 := Evaluate(fv, [lift_r[1] + (Kh ! delta)*Kh_x1x2.1, lift_r[2] + (Kh ! gamma)*Kh_x1x2.2]);
		    if #L eq 0 then
			L := [<f2,j+1>]; // Append does not always work properly with empty lists
		    else
			Append(~L, <f2,j+1>);
		    end if;
		end if;
	    end for;
	    v := val_i/(Norm_I^j); // returned value "by pointer"
	end if;
    end if;
end procedure;

function average_valuation_affine_TNFS_I_not_principal(f, I, Norm_I, delta, gamma, Oh1, FqZ, Fq_z1z2, map_Kh_Fq, Kh_x1x2)
    local L, v, vk;
    L := [<f,0>];
    v := QQ!0;
    while #L gt 0 do
	vk := QQ!0;
	average_valuation_affine_TNFS_I_not_principal_rec(I, Norm_I, delta, gamma, Oh1, FqZ, Fq_z1z2, map_Kh_Fq, Kh_x1x2, ~L,~vk);
	v := v+vk;
    end while;
    return v;
end function;

intrinsic average_valuation_homogeneous_coprime(f :: RngUPolElt, I_disc_f :: RngOrdIdl, I :: RngOrdIdl, Norm_I :: RngIntElt, Oh1 :: RngOrdIdl, Kh_x1x2 :: RngMPol) -> FldRatElt, BoolElt, BoolElt
{   return the average valuation and whether I is a bad prime ideal, whether I is a projective prime ideal
}
    local r, gamma, Fq, FqZ, map_Kh_Fq, ld_I, n_roots, proj_ideal, Oh;
    Oh := Order(Oh1);
    Fq, map_Kh_Fq := ResidueClassField(I);
    FqZ := PolynomialRing(Fq);
    //if (I_disc_f mod I) ne 0 then // good primes, exact formula
    if ((I_disc_f + I) eq Oh1) then
	n_roots, proj_ideal := number_of_roots_TNFS(f, FqZ, map_Kh_Fq);
        return n_roots/(Norm_I-1)*Norm_I/(Norm_I+1), false, proj_ideal; // nr * p / (p^2-1)
    else// bad prime ideal, recursive formula
	ld_I := ideal<Oh|LeadingCoefficient(f)>;
	proj_ideal := (ld_I + I) ne Oh1;
	I_pr, gamma := IsPrincipal(I);
	if I_pr then
	    r := average_valuation_affine_TNFS_I_principal(f, I, Norm_I, gamma, FqZ, map_Kh_Fq) * Norm_I;
	    // only if I is not coprime to the leading coefficient of f:
	    if proj_ideal then
		f_1x := Evaluate(Reverse(f),gamma*(Parent(f).1));
		r_pr := average_valuation_affine_TNFS_I_principal(f_1x, I, Norm_I, gamma, FqZ, map_Kh_Fq);
		r +:= r_pr;
	    end if;
	    r /:= Norm_I+1;
	    return r, true, proj_ideal;
	else
	    Fq_z1z2 := PolynomialRing(Fq,2); // bivariate poly f
	    delta := Generators(I)[1];
	    gamma := Generators(I)[2];
	    r := average_valuation_affine_TNFS_I_not_principal(f, I, Norm_I, delta, gamma, Oh1, FqZ, Fq_z1z2, map_Kh_Fq, Kh_x1x2) * Norm_I;
	    // only if I is not coprime to the leading coefficient of f:
	    if proj_ideal then //if (ld_I + I) ne Oh1 then
		f_1x := Evaluate(Reverse(f),delta*Kh_x1x2.1+gamma*Kh_x1x2.2);
		pr := average_valuation_affine_TNFS_I_not_principal(f_1x, I, Norm_I, delta, gamma, Oh1, FqZ, Fq_z1z2, map_Kh_Fq, Kh_x1x2);
		r +:= pr;
	    end if;
	    r /:= Norm_I+1;
	    return r, true, proj_ideal;
	end if;
    end if;
end intrinsic;

intrinsic alpha_TNFS_l(f :: RngUPolElt, I_disc_f :: RngOrdIdl, l :: RngIntElt, Oh1 :: RngOrdIdl, Kh_x1x2 :: RngMPol) -> FldReElt
{   Returns the sum of alpha values at prime ideals above the (integer) prime l
}
    local I, II, Norm_I, sum_val_I, Oh;
    Oh := Order(Oh1);
    sum_val_I := 0;
    for II in Factorization(ideal<Oh|l>) do
	I := II[1];
	//Norm_I := Abs(ZZ!Norm(I));
	// or:
	d_I := Degree(I);
	Norm_I := l^d_I;
	// Computes the contribution at prime ideal I of the alpha value of f
	sum_val_I +:= d_I*average_valuation_homogeneous_coprime(f, I_disc_f, I, Norm_I, Oh1, Kh_x1x2);
    // in case there are ideals of different degrees above the same prime (it happens for h of degree 3 for instance),
    // multiply by d_I inside the loop, where d_I is the degree of the ideal, and log(|Norm(I)|) = d_I*Log(l)
    end for;
    return RealField()! Log(l) * ( 1/(l-1)-sum_val_I);
end intrinsic;

intrinsic alpha_TNFS_2d(f :: RngUPolElt, B :: RngIntElt) -> FldReElt
{   Computes the alpha value of f, up to prime bound B
}
    local disc_f, I_disc_f, Oh, Oh1, Kh, Kh_x1x2;
    Kh := CoefficientRing(Parent(f));
    Kh_x1x2<x1,x2> := PolynomialRing(Kh,2);
    Oh := MaximalOrder(Kh);
    Oh1 := ideal<Oh|1>;
    disc_f := Discriminant(f);
    I_disc_f := ideal<Oh|disc_f>;

    return &+ [alpha_TNFS_l(f, I_disc_f, l, Oh1, Kh_x1x2): l in PrimesUpTo(B)];
end intrinsic;

/////////////////////////////////////////////////////////////////
/* To help to determine the type of objects:

QQ := Rationals();
QQs<s> := PolynomialRing(QQ);
h := s^2 + 1;
Kh<ah> := NumberField(h);
Oh := MaximalOrder(Kh);
I := ideal<Oh | ah+1>;
Oh1 := ideal<Oh | 1>;

Type(Oh1);
// RngOrdIdl
Parent(Oh1);
// Set of ideals of Maximal Equation Order with defining polynomial x^2 + 1 over ZZ
Order(Oh1);
// Maximal Equation Order with defining polynomial x^2 + 1 over ZZ
gamma := Generators(I);
Parent(gamma);
// Set of sequences over Maximal Equation Order with defining polynomial x^2 + 1 over ZZ

NumberField(Oh) eq Kh;
// true
Order(Oh1) eq Oh;
// true

Degree(Kh);
// 2
*/

//// Shashank Singh code (modified) with Monte Carlo estimate for bad ideals
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//intrinsic MonteCarlo_average_val_affine_TNFS(f :: RngUPolElt, badpI :: SeqEnum, badp :: SeqEnum, Oh :: RngOrd, Oh1 :: RngOrdIdl, deg_h :: RngIntElt, N :: RngIntElt) -> FldReElt
intrinsic MonteCarlo_average_val_affine_TNFS(f :: RngUPolElt, badpI :: SeqEnum, badp :: SeqEnum, Oh1 :: RngOrdIdl, deg_h :: RngIntElt, N :: RngIntElt) -> FldReElt
{   for each random coprime pair, compute the valuation at all bad primes
    f: polynomial in Oh[x]
    badpI: list of bad prime ideals
    badp: list of primes above which there is a bad prime ideal,
    the ideal at badpI[i] is above badp[i]
    Oh: the maximal order of Kh (Kh is the coefficient ring of f)
    Oh1: ideal<Oh|1> (for comparison: I1 and I2 are coprime <=> I1+I2 = Oh1)
    deg_h: degree of h, defining polynomial of Kh
    N: number of random pairs in Monte--Carlo simulation
    return the (estimated average) contribution in alpha of the bad primes (without the \log(l)/(l-1) part)
}
    local valSum, aa_coeffs, bb_coeffs, aa, bb, RI, alpha, Oh;
    Oh := Order(Oh1);
    valSum := [ 0.0 : pI in badpI ];
    alpha := 0.0;
    for i := 1 to N do
	repeat
	    // generate two coprime ideals in Oh (of any degree)
	    repeat
		aa_coeffs := [Random(N^2): i in [0..deg_h-1]];
		bb_coeffs := [Random(N^2): i in [0..deg_h-1]];
	    until Gcd(aa_coeffs cat bb_coeffs) eq 1;
	    aa:= Oh ! aa_coeffs;  bb:= Oh ! bb_coeffs;
	until (ideal<Oh|aa>+ideal<Oh|bb>) eq Oh1;// ideals are coprime
	RI := ideal<Oh|Resultant(f,aa+bb*Parent(f).1)>;
	for j := 1 to #badpI do
	    valSum[j] +:= Valuation(RI, badpI[j]); // badpI[j] is a bad prime ideal pI
	end for;
    end for;
    valSum := [vi/N: vi in valSum];
    for j := 1 to #badpI do
	alpha +:= Log(badp[j])*(-valSum[j]*Degree(badpI[j]));
    end for;
    return alpha;
end intrinsic;

////////////////////////////////////////////////////////////////////////////////

intrinsic alpha_TNFS_2d_MC(fX :: RngUPolElt, pmax :: RngIntElt, N :: RngIntElt) -> FldReElt, RngIntElt
{   N := no of (a,b) pairs tested for bad ideals; pmax := 5000 is a good option
}
    local alpha, X, Kh, hY, y, Oh, Y, bad_fact, badp, badp_princ, badpI, badpI_princ, \
	  l,val,pI,d,OhModI,sigma,OhModIXbar,fXbar,mp,norm_pI,valpI, Oh1,nb_ideals;
    alpha := 0.0;
    X := Parent(fX).1;
    Kh := CoefficientRing(fX);
    hY := DefiningPolynomial(Kh);
    deg_h := Degree(hY);
    y := Kh.1;
    Oh := MaximalOrder(Kh);
    Y := Parent(hY).1;
    Oh1 := ideal<Oh|1>; // ideal containing all, for testing wether two ideals are coprime
    //bad_fact:= Discriminant(hY)*Discriminant(fX)*LeadingCoefficient(hY)*LeadingCoefficient(fX);
    bad_fact:= Discriminant(fX);
    I_bad_fact := ideal<Oh|bad_fact>;
    badpI := [];
    badp := [];
    badp_princ :=[];
    badpI_princ :=[];
    nb_ideals := 0;
    // This sort the prime integers in good/bad
    // but it can be that above a given prime number, there is a bad prime ideal and a good prime ideal.
    // so sort the ideals into good/bad, not the prime numbers
    for l in PrimesUpTo(pmax) do
        val := 0.0;
        for pI in [i[1]: i in Factorisation(ideal<Oh|l>)] do
	    nb_ideals +:= 1;
	    // if ... test if pI and bad_fact are coprime ideals
	    d := Degree(pI);
	    if ((pI + I_bad_fact) eq Oh1) then // they are coprime
		OhModI, sigma := ResidueClassField(Oh,pI);
		OhModIXbar<Xbar> := PolynomialRing(OhModI);
		fXbar := OhModIXbar!([sigma(a): a in Eltseq(fX)]);
		if fXbar ne 0 then
		    mp := #Roots(fXbar); // Note that: it counts only the distinct roots, no repeated roots
		    if Degree(fXbar) lt Degree(fX) then
			mp +:= 1;
		    end if;
		else
		    mp := Degree(fX);
		end if;
		norm_pI :=  Norm(pI);
		valpI := 1.0*mp*norm_pI/(norm_pI^2-1);
		//printf " Valuation = %.4o and Ideal = %o\n", valpI, <i:i in Generators(pI)>;
		val +:= d*valpI;
	    else // MonteCarlo technique, before some better exact algorithm is available
		//printf "pI = %o is a bad prime\n", pI;
		if IsPrincipal(pI) then
		    Append(~badpI_princ, pI);
		    Append(~badp_princ, l);
		else
		    Append(~badpI, pI);
		    Append(~badp, l);
		end if;
	    end if;
        end for;
        alpha +:= Log(l)*( 1/(l-1) - val );
    end for;
    // now bad primes: re-use the random values for each bad prime ideal
    //printf "%o and %o bad prime ideals above primes %o and %o (principal ones)\n", #badpI, #badpI_princ, badp, badp_princ;
    //alpha +:= MonteCarlo_average_val_affine_TNFS(fX, badpI_princ cat badpI, badp_princ cat badp, Oh, Oh1, deg_h, N);
    alpha +:= MonteCarlo_average_val_affine_TNFS(fX, badpI_princ cat badpI, badp_princ cat badp, Oh1, deg_h, N);
    return alpha, nb_ideals;
end intrinsic;
/////////////////////////////////////////////////////////////////
