
# This file was *autogenerated* from the file enumerate_sparse_T.sage
from sage.all_cmdline import *   # import sage library
import itertools

_sage_const_2 = Integer(2)

import sage

def get_sparse_T_HW_gen(length, hw):
    """
    This function is a generator. It generates all integers x such that:
     - 2^(length-1) <= x < 2^length ; that is, the binary expansion of x
       has exactly (length) bits, viz. its largest summand is
       2^(length-1)
     - and the Hamming weight HW(x) is such that HW(x) == hw.
    We require that hw be a positive integer.

    sage: list(get_sparse_T_HW_gen(2, 1))
    [2]

    sage: list(get_sparse_T_HW_gen(4, 2))
    [9, 10, 12]

    sage: len(list(get_sparse_T_HW_gen(10, 6)))
    126

    """
    top = _sage_const_2**(length-1)
    if hw==1 :
        yield top
    else:
        for i1 in range(1,length):
            for w in get_sparse_T_HW_gen(i1, hw-1):
                yield top + w

def get_sparse_T_HW(length, hw):
    """
    This is a just a convenience wrapper around get_sparse_T_HW_gen if
    one wants to avoid writing list() around the generator function

    sage: len(get_sparse_T_HW(10, 4))
    84

    """
    L = list(get_sparse_T_HW_gen(length, hw))
    assert len(L) == binomial(length-1, hw-1)
    return L

def get_sparse_T_uptoHW_gen(length, hw):
    """
    This function is a generator. It generates all integers x such that:
     - 2^(length-1) <= x < 2^length ; that is, the binary expansion of x
       has exactly (length) bits, viz. its largest summand is
       2^(length-1)
     - and the Hamming weight HW(x) is such that HW(x) <= hw.
    We require that hw be a positive integer.

    sage: list(get_sparse_T_uptoHW_gen(4, 2))
    [8, 9, 10, 12]

    sage: len(list(get_sparse_T_uptoHW_gen(10, 6)))
    382
    """

    for i in range(1, hw+1):
        for c in get_sparse_T_HW_gen(length, i):
            yield c

def get_sparse_T_uptoHW(length, hw):
    """
    This is a just a convenience wrapper around get_sparse_T_uptoHW_gen
    if one wants to avoid writing list() around the generator function

    sage: len(get_sparse_T_uptoHW(10, 4))
    130

    """
    L = list(get_sparse_T_uptoHW_gen(length, hw))
    assert len(L) == sum([binomial(length-1, k) for k in range(hw)])
    return L

# This iterates over all integers in 2-NAF form sum([s[i]*2^i for i in
# range(n)]) with the conditions s[n-1]==1, s[i] in {-1,0,1} and
# s[i]*s[i+1]==0 (the two latter are necessary to guarantee uniqueness of
# the 2-naf form).
#
# Note that some of the integers in the range [2^(k-1),2^k-1], while
# their binary expansion has 2^(k-1) as the most significant summand, the
# same does not hold in 2-NAF form, as some have 2^k as the largest
# summand.
def get_sparse_T_HW_NAF_gen(length, hw):
    """
    This function is a generator. It generates all integers x such that:
     - The largest summand of the binary non-adjacent (2-NAF) expansion of x
       is +2^(length-1). Note that this does *not* imply that x<2^length
     - and the 2-NAF weight HW_{2-NAF}(x) is such that HW_{2-NAF}(x) == hw.
    We require that hw be a positive integer.

    The generated integers are not sorted.

    sage: list(get_sparse_T_HW_NAF_gen(10, 2))
    [511, 513, 510, 514, 508, 516, 504, 520, 496, 528, 480, 544, 448, 576, 384, 640]

    """
    top = _sage_const_2**(length-1)
    if hw==1 :
        yield top
    else:
        for i1 in range(1,length-1):
            for w in get_sparse_T_HW_NAF_gen(i1, hw-1):
                yield top - w
                yield top + w

def get_sparse_T_HW_NAF(length, hw):
    """
    This is a just a convenience wrapper around get_sparse_T_HW_NAF_gen
    if one wants to avoid writing list() around the generator function

    sage: len(get_sparse_T_HW_NAF(14, 4))
    960
    """
    L = list(get_sparse_T_HW_NAF_gen(length, hw))
    # It's a bit empirical, but a posteriori analysis sort of gives a
    # proof. I think it's correct...
    assert len(L) == _sage_const_2**(hw-1)*binomial(length-hw, hw-1)
    return L

def get_sparse_T_uptoHW_NAF_gen(length, hw):
    """
    This function is a generator. It generates all integers x such that:
     - The largest summand of the binary non-adjacent (2-NAF) expansion of x
       is +2^(length-1). Note that this does *not* imply that x<2^length
     - and the 2-NAF weight HW_{2-NAF}(x) is such that HW_{2-NAF}(x) <= hw.
    We require that hw be a positive integer.

    The generated integers are not sorted.

    sage: len(list(get_sparse_T_uptoHW_NAF_gen(10, 3)))
    101
    """
    for i in range(1, hw+1):
        for c in get_sparse_T_HW_NAF_gen(length, i):
            yield c

def get_sparse_T_uptoHW_NAF(length, hw):
    """
    This is a just a convenience wrapper around get_sparse_T_uptoHW_NAF_gen
    if one wants to avoid writing list() around the generator function

    sage: len(get_sparse_T_uptoHW_NAF(14, 4))
    1205
    """
    L = list(get_sparse_T_uptoHW_NAF_gen(length, hw))
    assert len(L) == sum([_sage_const_2**k*binomial(length-k-1, k) for k in range(hw)])
    return L

def bits_2naf(x):
    """
    This functions returns the binary non-adjacent form of x. It is
    uniquely defined. The i-th item in the returned list is the
    multiplier attached to 2^i in the 2-NAF.

    sage: bits_2naf(3456780)
    [0, 0, -1, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, -1, 0, 1]

    """
    L = []
    xx = Integer(x)
    assert x >= 0
    while xx > 0 :
        rr = xx % 4
        if rr == 3 :
            rr = -1
        else:
            rr = rr%2
        L.append(rr)
        xx -= rr
        xx,rr = xx.quo_rem(2)
        assert rr == 0
    assert x == sum([r*_sage_const_2**i for i,r in enumerate(L)])
    return L

def bit_positions(n):
    """
    This function returns the positions of the non-zero bits in the
    binary expansion of n. The length of the returned list is the Hamming
    weight of n

    sage: bit_positions(123)
    [0, 1, 3, 4, 5, 6]
    """
    bn = Integer(n).bits()
    return [i for i in range(len(bn)) if bn[i] != 0]

def bit_positions_2naf(x):
    """
    This function returns the positions of the non-zero summands in the
    2-NAF of x, together with the attached coefficient (which is -1 or
    +1).

    sage: bit_positions_2naf(123)
    [(0, -1), (2, -1), (7, 1)]
    """
    L = []
    xx = Integer(x).abs()
    assert xx >= 0
    i = 0
    while xx > 0 :
        rr = xx % 4
        if rr == 3 :
            rr = -1
        else:
            rr = rr%2
        L.append((i,rr))
        xx -= rr
        xx,rr = xx.quo_rem(2)
        assert rr == 0
        i += 1
    L = [u for u in L if u[1] != 0]
    if x < 0:
        L = [(i,-m) for i,m in L]
    assert Integer(x) == sum([r*_sage_const_2**i for i,r in L])
    return L

# Some NAF results.
#
# The smallest positive integer with 2-NAF weight equal to k is:
#
#  n = (2^(2*k-1)+1)//3
#
# When we add 1 to an integer n whose 2-NAF form is given by
# twonaf(n)=L=[(i,r),...], of weight two_naf_weight(n)=len(L)=h, we have
#
# For n = 0 mod 4,  L2naf(n+1)=[(0,1)]+L   W2naf(n+1)-W2naf(n)=+1
# For n = -1 mod 4, L2naf(n+1)=L[1:]       W2naf(n+1)-W2naf(n)=-1
# For n = 1 mod 8, L2naf(n+1)=[(1,1)]+L[1:]       W2naf(n+1)-W2naf(n)=0
# For n = 5 mod 8, i.e. n=4m+1 with m odd, we have:
#                   L2naf(n)=[(0,1)]+L2naf(4*m)
#                   W2naf(n)=1+W2naf(m)
#                   L2naf(n+1)=[(1,-1)]+L2naf(4*(m+1))
#                   W2naf(n+1)=1+W2naf(m+1), 
#                   W2naf(n+1)-W2naf(n)=W2naf(m+1)-W2naf(m)
# For n = 2 mod 8, i.e. n=8m+2
#                   L2naf(n)=[(1,1)]+L2naf(8*m)
#                   W2naf(n)=1+W2naf(m)
#                   L2naf(n+1)=[(0,-1)]+L2naf(4*(2*m+1))
#                   W2naf(n+1)=1+W2naf(2*m+1), 
#                   W2naf(n+1)-W2naf(n)=W2naf(2*m+1)-W2naf(2*m)
# For n = -2 mod 8, i.e. n=8m-2
#                   L2naf(n)=[(1,-1)]+L2naf(8*m)
#                   W2naf(n)=1+W2naf(m)
#                   L2naf(n+1)=[(0,-1)]+L2naf(8*m)
#                   W2naf(n+1)=W2naf(m)
#                   W2naf(n+1)-W2naf(n)=-1
#
# It follows that W2naf(n+1)-W2naf(n) is always -1,0,or +1 and that
# W2naf(n+1) <= W2naf(n) when n is odd
#
# Interesting cases:
# n  W2naf L2naf  n+1 W2naf L2naf
# 18 2     16+2   19  3     16+4-1

def next_element_with_given_hamming_weight(n0, hw):
    """
    For positive input n0, this auxiliary function computes the smallest
    integer n such that:
     - n >= n0
     - the Hamming weight HW(n) is HW(n)==hw
    For n0 negative, this returns the opposite of what is returned for -n0

    sage: n0 = 10123765
    sage: w = 4
    sage: n = next_element_with_given_hamming_weight(n0, w)
    sage: n
    10223616

    sage: w in set([len(bit_positions(x)) for x in range(n0,n)])
    False

    """
    if n0 < 0:
        return -next_element_with_given_hamming_weight(-n0, hw)
    n = n0
    # first add values that leave the Hamming weight constant, or
    # decrease it.
    while True:
        bits = bit_positions(n)
        # print("bits of {}: {}".format(n, bits))
        if len(bits) <= hw:
            break
        n += _sage_const_2**bits[0]
    # And then, increase the Hamming weight carefully, starting from the
    # lower bits.
    c = 1
    while len(bits) < hw:
        n |= c
        bits = bit_positions(n)
        c = c+c
    assert n >= n0 and len(bits) == hw
    return n

def next_element_with_given_2naf_weight(n0, hw):
    """
    For positive input n0, this auxiliary function computes the smallest
    integer n such that:
     - n >= n0
     - the 2-NAF weight HW_{2-NAF}(n) is HW_{2-NAF}(n)==hw
    For n0 negative, this returns the opposite of what is returned for -n0

    sage: n0 = Integer(12378126)
    sage: w = 5
    sage: n = next_element_with_given_2naf_weight(n0, w)
    sage: n
    12382208

    sage: w in set([len(bit_positions_2naf(x)) for x in range(n0,n)])
    False

    sage: next_element_with_given_2naf_weight(18,3)
    19
    """
    if n0 < 0:
        return -next_element_with_given_2naf_weight(-n0, hw)
    if n0 == 0:
        return (_sage_const_2**(2*hw-1)+1)//3
    n = n0
    # first add values that leave the Hamming weight constant, or
    # decrease it.
    while True:
        bits = bit_positions_2naf(n)
        # print("bits of {}: {}".format(n, bits))
        if len(bits) <= hw:
            break
        i,r = bits[0]
        # if r=-1, this will decrease the weight by 1. if r=+1, then it
        # may decrease the weight, but it will not increase it (use the
        # property W2naf(n+1) <= W2naf(n) for n odd.
        n += _sage_const_2**i
    # And then, increase the 2-NAF weight carefully, starting from the
    # lower bits. The full extent of the reasoning behind the operations
    # below is better detailed in increase_list_of_positions_2naf.
    #
    # First chop off the lower summands until the point where we can
    # compensate with only low-order terms. Maybe we'll actually decrease
    # the weight even more, but we won't do so indefinitely. The real
    # thing we care about is that we don't want to miss any increase that
    # would lead us exactly where we want to be.
    k = hw-len(bits)
    while bits[0][0] < _sage_const_2*k:
        i = bits[0][0]
        if i==0 or bits[0][1]==-1 :
            n += _sage_const_2**i
        else:
            n += _sage_const_2**(i-1)
        bits = bit_positions_2naf(n)
        k = hw-len(bits)
    if k>0 :
        # this increment has 2-NAF form [-1,0,-1,0,...,0,1] with exactly k
        # non-zero summmands, and it is the smallest integer with w-NAF
        # form having this weight. Since by construction bits[0][0]>=2*k,
        # adding this will preserve the 2-NAF weight.
        n += (_sage_const_2**(2*k-1)+1)//3
    return n

def increase_list_of_positions(n, L=None):
    """
    given a sorted list L of bit positions representing the integers
    sum([2^i for i in L]), return the following integer with the same
    Hamming weight.

    This is an auxiliary function, and we require that
    L==bit_positions(n) (actually the default value L == None also works)

    sage: increase_list_of_positions(123678)
    (123687, [0, 1, 2, 5, 8, 9, 13, 14, 15, 16])

    sage: increase_list_of_positions(291)
    (293, [0, 2, 5, 8])
    """
    assert n >= 0
    if n == 0:
        raise StopIteration
    if L is None:
        L = bit_positions(n)
    # We first compute the integer m such that
    # L[i]==L[0]+i for all integers i < m. (that is, we know that
    # at least the first (m) lowermost consecutive bits following
    # the first-set bit are all ones). It follows from this that the
    # smallest increment that does not increase the Hamming weight is by
    # L[0] -- actually it *decreases* the Hamming weight by (m-1),
    # but maybe more. Next, we have to add the bits [0,...,m-2] in
    # order to compensate the weight loss.
    w = len(L)
    m = 0
    while m < w and L[m] == L[0] + m:
        m += 1
    assert m >= 1
    # We add 2^L[0] + 2^(m-1) - 1
    # adding 2^L[0] means changing L[0:m] to
    # [0..m-2]+(L[m-1]+1)
    n += _sage_const_2**L[0]+_sage_const_2**(m-1)-1
    L = list(range(m-1))+[L[m-1]+1]+L[m:]
    return n, L

def decrease_list_of_positions(n, L=None):
    """
    This is the converse of increase_list_of_positions. Note that there
    is a smallest positive integer with a given Hamming weight, in which
    case we can't return a previous one. We raise StopIteration in that
    case.
    
    sage: n = 123123897
    sage: L = bit_positions(n)
    sage: n1,L1 = increase_list_of_positions(n,L)
    sage: n2,L2 = decrease_list_of_positions(n1,L1)
    sage: (n,L)==(n2,L2)
    True
    """
    assert n >= 0
    if L is None:
        L = bit_positions(n)
    w = len(L)
    if n == _sage_const_2**w-1 :
        # Nothing we can do.
        raise StopIteration
    if L[0] > 0 :
        L[0] -= 1
        n -= _sage_const_2**L[0]
    else:
        m = 0
        while m < w and L[m] == m:
            m += 1
        # Then we'll do the reciprocal of the increase() thing
        assert m < w
        # avoid headaches, align m to exactly the same thing as it is in
        # the code we want to roll back.
        m += 1
        oldLm1 = L[m-1]-1
        oldL0 = oldLm1-(m-1)
        n -= _sage_const_2**oldL0 + _sage_const_2**(m-1)-1
        L = list(range(oldL0, oldL0+m))+L[m:]
    return n, L

def increase_list_of_positions_2naf(n, L=None, d=1):
    """
    given a sorted list L=[(i,r)] representing the integer
    n=sum([2^i*r for i in L]) (i in increasing order), return the integer
    above n with the same 2-NAF weight.

    This is an auxiliary function, and we require that
    L==bit_positions_2naf(n) (actually the default value L == None also works)

    The argument d gives the "direction". Everything is written with d=1
    in mind, and d is just here to include the necessary adjustments to
    make it all work.

    sage: increase_list_of_positions_2naf(853)
    (1195, [(0, -1), (2, -1), (4, -1), (6, -1), (8, 1), (10, 1)])

    sage: increase_list_of_positions_2naf(899)
    (901, [(0, 1), (2, 1), (7, -1), (10, 1)])

    sage: increase_list_of_positions_2naf(901)
    (902, [(1, -1), (3, 1), (7, -1), (10, 1)])

    sage: increase_list_of_positions_2naf(903)
    (905, [(0, 1), (3, 1), (7, -1), (10, 1)])

    sage: increase_list_of_positions_2naf(928)
    (944, [(4, -1), (6, -1), (10, 1)])

    sage: increase_list_of_positions_2naf(1367)
    (1369, [(0, 1), (3, -1), (5, -1), (7, -1), (9, -1), (11, 1)])

    sage: increase_list_of_positions_2naf(1369)
    (1370, [(1, 1), (3, -1), (5, -1), (7, -1), (9, -1), (11, 1)])

    sage: increase_list_of_positions_2naf(1370)
    (1371, [(0, -1), (2, -1), (5, -1), (7, -1), (9, -1), (11, 1)])

    sage: increase_list_of_positions_2naf(2740)
    (2742, [(1, -1), (3, -1), (6, -1), (8, -1), (10, -1), (12, 1)])

    sage: w=6
    sage: n=(2^(2*w-1)+1)//3
    sage: L=bit_positions_2naf(n)
    sage: for i in range(10000): n,L=increase_list_of_positions_2naf(n,L)
    sage: n
    30345

    sage: for i in range(10000): n,L=increase_list_of_positions_2naf(n,L,d=-1)
    sage: n
    683
    """
    assert n >= 0
    if n == 0:
        raise StopIteration
    if L is None:
        L = bit_positions_2naf(n)

    # Recall the following (we denote D(n)=W2naf(n+1)-W2naf(n)
    #
    # n = -1 mod 4,                    D(n)=-1
    # n = 1 mod 8,                     D(n)=0
    # n = 5 mod 8, i.e. n=4m+1 [m odd] D(n)=D(m)
    # n = 0 mod 4,                     D(n)=+1
    # n = 2 mod 8, i.e. n=8m+2         D(n)=D(2*m)
    # n = -2 mod 8, i.e. n=8m-2        D(n)=-1
        
    i,r = L[0]
    # First handle some easy cases. These can be subsumed by the other
    # cases.
    if r == -d:
        if i > 0 :
            L[0] = (i-1, r)
            n += d*_sage_const_2**(i-1)  # could be done with a bitwise OR
        else:
            L[0] = (0, d)
            n += d*2
    elif i==0 and (n == 1 or L[1][0] >= 3):
        # n is 1 mod 8
        L[0] = (1, d)
        n += d
    else:
        # Then we're interested in identifying the cases with hard
        # increments. Assume that the 2-naf form of n is:
        #    n = [Z 10 10 10 10 0x yz]  (case (A))
        # or n = [Z 10 10 10 10 m0 yz]  (case (B))
        #
        # where Z is made of i zeroes, m denotes -1, xyz is arbitrary,
        # and the number of 10 blocks is arbitrary. We'll count it as k,
        # which is 
        v = valuation(3*d*n+_sage_const_2**i, 2)-i
        k = v // 2
        assert L[:k]==[(2*j+i, d) for j in range(k)]
        if v%2 ==0 :
            # In case (A), we have
            #     3n+2^i = [Z 00 00 00 00 1x yz] has v even
            #  n+2^(i-1) = [M 0m 0m 0m 01 0x yz] has larger weight
            #      n+2^i = [Z 0m 0m 0m 01 0x yz] has the same weight as n
            # (where M is a block with (i-1) zeroes, then -1)
            for j in range(k-1):
                L[j] = (2*j+1 +i, -d)
            L[k-1] = (2*(k-1)+1 +i, d)
            n += d*_sage_const_2**i
        else:
            # In case (B), we have
            #         3n+2^i = [Z 00 00 00 00 0m xyz] has v odd
            assert L[k]==(_sage_const_2*k+i, -d)
            if i > 0 :
                # Then an increment 2^(i-1) is possible, and we'll use
                # it.
                #       2^(2k+i) = [Z 00 00 00 00 1]
                #      n+2^(i-1) = [M 0m 0m 0m 0m 00xyz] has the same weight
                # (where M is a block with (i-1) zeroes, then -1)
                for j in range(k+1):
                    L[j] = (2*j+i-1, -d)
                n += d*_sage_const_2**(i-1)
            else:
                # Otherwise we can only add 2^i==1, which makes it harder
                # to reach the same weight again. Cf the family of
                # integers (5*2^(2*k+1)-1)/3
                #
                #         2^(2k) = [  00 00 00 00 1]
                # C=(2^(2k)-1)/3 = [  10 10 10 10 0]
                # recall:      n = [  10 10 10 10 m0 yz]  (case (B))
                #            n+1 = [  0m 0m 0m 0m 00 yz] has lower weight
                #  n-2C+2^(2k+1) = [  m0 m0 m0 m0 10 yz] is the next with the
                #                  same weight.
                # = n + (2-2^v+3*2^v)/3 = (2^(v+1)+2)/3
                for j in range(k):
                    L[j] = (2*j, -d)
                L[k] = (2*k, d)
                n += d*(_sage_const_2**(v+1)+2) // 3
    return n,L


class enumerator_factory_hamming():
    @staticmethod
    def successor(n, hw):
        """
        returns x >= n with hamming weight equal to hw

        sage: enumerator_factory_hamming.successor(0, 3)
        7

        sage: enumerator_factory_hamming.successor(-2, 3)
        7

        sage: enumerator_factory_hamming.successor(-7,3)
        -7

        """
        x = next_element_with_given_hamming_weight(n, hw)
        if n >= 0 or x == n:
            return x
        else:
            assert x < n
            try:
                x,bits = decrease_list_of_positions(-x)
                return -x
            except StopIteration:
                return next_element_with_given_hamming_weight(0, hw)

    @staticmethod
    def predecessor(n, hw):
        return -enumerator_factory_hamming.successor(-n, hw)

    @staticmethod
    def bitpos(n):
        return bit_positions(n)

    @staticmethod
    def incpos(n, bits):
        return increase_list_of_positions(n, bits)

    @staticmethod
    def decpos(n, bits):
        return decrease_list_of_positions(n, bits)

class enumerator_factory_2naf():
    @staticmethod
    def successor(n, hw):
        return next_element_with_given_2naf_weight(n, hw)
        if n >= 0 or x == n:
            return x
        else:
            assert x < n
            try:
                x,bits = increase_list_of_positions_2naf(-x, d=-1)
                return -x
            except StopIteration:
                return next_element_with_given_2naf_weight(0, hw)

    @staticmethod
    def predecessor(n, hw):
        return -enumerator_factory_2naf.successor(-n, hw)

    @staticmethod
    def bitpos(n):
        return bit_positions_2naf(n)

    @staticmethod
    def incpos(n, bits):
        return increase_list_of_positions_2naf(n, bits)

    @staticmethod
    def decpos(n, bits):
        return increase_list_of_positions_2naf(n, bits, -1)

class stateful_iter_chain(object):
    def __init__(self, *args):
        self.iters = [iter(x) for x in args]
        self.index = 0
        self.previous_state = self.getstate()

    def __repr__(self):
        r = "stateful chain of: " 
        for i in self.iters:
            r += repr(i)
        return r

    def __iter__(self):
        return self

    def __next__(self):
        return self.next()

    def next(self):
        if self.index is None:
            raise StopIteration
        self.previous_state = self.getstate()
        while self.index < len(self.iters):
            try:
                return next(self.iters[self.index])
            except StopIteration:
                self.index += 1
        self.index = None
        raise StopIteration

    def getstate(self):
        return (self.index, self.iters[self.index].getstate())

    def setstate(self, state):
        self.previous_state = state
        self.index = state[0]
        self.iters[self.index].setstate(state[1])

class stateful_iter_map(object):
    def __init__(self, f, it):
        self.it = iter(it)
        self.f = f
        self.previous_state = self.getstate()

    def __iter__(self):
        return self

    def __next__(self):
        return self.next()

    def next(self):
        self.previous_state = self.getstate()
        return self.f(next(self.it))

    def getstate(self):
        return self.it.getstate()

    def setstate(self, state):
        self.previous_state = state
        self.it.setstate(state)

class enumerator_factory(object):
    """
    sage: list(enumerator_factory(enumerator_factory_2naf, 1, -1, 2))
    [-1, 1]

    sage: list(enumerator_factory(enumerator_factory_2naf, 2,-30,20))
    [-30, -28, -24, -20, -18, -17, -15, -14, -12, -10, -9, -7, -6, -5, -3, 3, 5, 6, 7, 9, 10, 12, 14, 15, 17, 18]
    
    sage: list(enumerator_factory(enumerator_factory_hamming, 2,-30,20))
    [-24, -20, -18, -17, -12, -10, -9, -6, -5, -3, 3, 5, 6, 9, 10, 12, 17, 18]

    sage: list(enumerator_factory(enumerator_factory_2naf, 2,-30,20, up_to=True))
    [0, -16, -8, -4, -2, -1, 1, 2, 4, 8, 16, -30, -28, -24, -20, -18, -17, -15, -14, -12, -10, -9, -7, -6, -5, -3, 3, 5, 6, 7, 9, 10, 12, 14, 15, 17, 18]

    sage: list(enumerator_factory(enumerator_factory_2naf, 1,16,8,-1))
    [8]
    """
    class _iter():
        def __init__(self, parent):
            self.parent = parent
            self.factory = parent.factory
            self.n0 = self.factory.successor(self.parent.n0, self.parent.w)
            self.n1 = self.factory.successor(self.parent.n1, self.parent.w)
            self.bits = self.factory.bitpos(self.n0)
            self.n = self.n0
            self.previous_state = self.getstate()

        def __iter__(self):
            return self

        # Python 3 compatibility
        def __next__(self):
            return self.next()

        def getstate(self):
            return self.n

        def setstate(self, n):
            self.previous_state = n
            self.n = n
            self.bits = self.factory.bitpos(self.n)

        def next(self):
            self.previous_state = self.getstate()
            if self.parent.direction==1 :
                if self.n >= self.n1:
                    raise StopIteration
                cur = self.n
                self.n, self.bits = self.factory.incpos(self.n, self.bits)
                return cur
            else:
                # direction==-1, so n1 is the small one.
                self.n, self.bits = self.factory.decpos(self.n, self.bits)
                if self.n >= self.n1:
                    return self.n
                else:
                    raise StopIteration

    def __init__(self, factory, hw, n0, n1, direction=1, up_to=False):
        assert hw >= 0
        assert direction == 1 or direction == -1
        self.factory = factory
        self.w = hw
        self.n0 = n0
        self.n1 = n1
        self.direction = direction
        self.up_to = up_to

    def __reversed__(self):
        return self.__class__(self.factory, self.w, self.n1, self.n0, -self.direction, up_to=self.up_to)

    def __iter__(self):
        if self.up_to:
            return stateful_iter_chain(*[self.__class__(self.factory, w, self.n0, self.n1, self.direction) for w in range(self.w + 1)])
        w = self.w
        n0 = self.n0
        n1 = self.n1
        d = self.direction
        if w == 0:
            class stateful_singleton_iterator(object):
                def __init__(self, x):
                    self.x = x
                    self.previous_state = self.getstate()
                def __iter__(self):
                    return self
                def __next__(self):
                    return self.next()
                def next(self):
                    self.previous_state = self.getstate()
                    if self.x is None:
                        raise StopIteration
                    x = self.x
                    self.x = None
                    return x
                def getstate(self):
                    return self.x
                def setstate(self, state):
                    self.previous_state = state
                    self.x = state
            return stateful_singleton_iterator(0)
        if sign(n0) * sign(n1) >= 0:
            if n0 >= 0:
                return enumerator_factory._iter(self)
            else:
                # Assuming d=1, we want to iterate over n0 <= n < n1.
                # We're actually going to iterate over -n0 >= -n > -n1,
                # which is the same as 1-n0 > n >= 1-n1
                ii = self.__class__(self.factory, w, 1-n0, 1-n1, -d)
                return stateful_iter_map(lambda x:-x, ii)
        else:
            if n0 < 0:
                if d < 0:
                    return iter([])
                # n0 <= n < 0  and 0 <= n < n1
                # the former becomes
                neg_only = self.__class__(self.factory, w, 1-n0, 1, -d)
                pos_only = self.__class__(self.factory, w, 0, n1, d)
                ii0 = enumerator_factory._iter(neg_only)
                ii0 = stateful_iter_map(lambda x:-x, ii0)
                ii1 = enumerator_factory._iter(pos_only)
                return stateful_iter_chain(ii0, ii1)
            else:
                if d > 0:
                    return iter([])
                # n0 > n >= 0  and 0 > n >= n1
                # the latter becomes 0 < -n <= -n1 i.e. 1 <= -n < 1-n1
                pos_only = self.__class__(self.factory, w, n0, 0, d)
                neg_only = self.__class__(self.factory, w, 1, 1-n1, -d)
                ii0 = enumerator_factory._iter(neg_only)
                ii1 = enumerator_factory._iter(pos_only)
                ii1 = stateful_iter_map(lambda x:-x, ii1)
                return stateful_iter_chain(ii0, ii1)

class sparse_integers_in_interval(object):
    """
    This generator object enumerates integers n such that:
     - n0 <= n < n1  (or, if direction==-1: n0 > n >= n1)
     - the Hamming weight HW(n) of x is HW(n)==hw

    sage: list(sparse_integers_in_interval(6, 10^6, 10^6+3000))
    [1000448, 1001472]

    sage: n0 = 10^9
    sage: n1 = 10^9+10^5
    sage: w = 11
    sage: list(sparse_integers_in_interval(w, n0, n1)) == [x for x in range(n0, n1) if len(bit_positions(x))==w]
    True

    Note that the output integers are sorted in increasing order, and
    that it is even possible to reverse the iterator at no cost.

    sage: list(reversed(sparse_integers_in_interval(2, 2000, 2500)))
    [2304, 2176, 2112, 2080, 2064, 2056, 2052, 2050, 2049]

    """
    def __init__(self, *args, **kw):
        self.base = enumerator_factory(enumerator_factory_hamming, *args, **kw)
    def __reversed__(self):
        return reversed(self.base)
    def __iter__(self):
        return self.base.__iter__()

class sparse_2naf_integers_in_interval(object):
    """
    This generator object enumerates integers n such that:
     - n0 <= n < n1  (or, if direction==-1: n0 > n >= n1)
     - the 2-NAF weight HW_{2-NAF}(n) of x is HW_{2-NAF}(n)==hw

    sage: list(sparse_2naf_integers_in_interval(5, 10^6, 10^6+400))
    [1000000, 1000064, 1000192, 1000320, 1000384]

    sage: n0 = 10^9
    sage: n1 = 10^9+10^4
    sage: w = 8
    sage: list(sparse_2naf_integers_in_interval(w, n0, n1)) == [x for x in range(n0, n1) if len(bit_positions_2naf(x))==w]
    True

    Note that the output integers are sorted in increasing order, and
    that it is even possible to reverse the iterator at no cost.

    sage: list(reversed(sparse_2naf_integers_in_interval(2, 2000, 2500)))
    [2304, 2176, 2112, 2080, 2064, 2056, 2052, 2050, 2049, 2047, 2046, 2044, 2040, 2032, 2016]

    """
    def __init__(self, *args, **kw):
        self.base = enumerator_factory(enumerator_factory_2naf, *args, **kw)
    def __reversed__(self):
        return reversed(self.base)
    def __iter__(self):
        return self.base.__iter__()

